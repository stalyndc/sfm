<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>A Random Walk Through Geek-Space</title>
    <link>https://www.sebastiansylvan.com/</link>
    <description>Recent content on A Random Walk Through Geek-Space</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 25 May 2022 21:05:32 -0700</lastBuildDate>
    
	<atom:link href="https://www.sebastiansylvan.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Header Hygiene</title>
      <link>https://www.sebastiansylvan.com/post/header_hygiene/</link>
      <pubDate>Wed, 25 May 2022 21:05:32 -0700</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/header_hygiene/</guid>
      <description>Quick note on one approach for maintaining fast compile times, inspired by Sebastian Aaltonen&amp;rsquo;s tweet here.
This is something that we used to do at Rare when I was there ages ago. It&amp;rsquo;s been a long time so I may be misrepresenting it, and it wasn&amp;rsquo;t rigidly followed even then, but I always thought it was a good idea.
The key point is to split the header for a .cpp file into two headers.</description>
    </item>
    
    <item>
      <title>A Fast Sudoku Solver</title>
      <link>https://www.sebastiansylvan.com/post/sudoku/</link>
      <pubDate>Thu, 16 Aug 2018 20:16:45 -0700</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/sudoku/</guid>
      <description>Everyone has to write a Sudoku solver! A few months back I was in an hotel room at 4 am in the morning when the thermostat inexplicably decided to heat my room to 90 degrees Fahrenheit. That woke me up, and since I had nothing to do for a few hours I decided to write a Sudoku solver (because everyone has to write one).
I hadn&amp;rsquo;t thought about it since then, until I ran across this post on reddit and decided to run the same puzzles through my solver and see how it did.</description>
    </item>
    
    <item>
      <title>Thoughts on light culling for clustered shading</title>
      <link>https://www.sebastiansylvan.com/post/light_culling/</link>
      <pubDate>Tue, 05 Dec 2017 20:49:19 -0800</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/light_culling/</guid>
      <description>A while back I came across the presentation Improved Culling for Tiled and Clustered Shading by Michal Drobot and it&amp;rsquo;s really clever. It inspired a bunch of thoughts that I&amp;rsquo;ve been meaning to try out but since it&amp;rsquo;s now several months later and I still haven&amp;rsquo;t got around to it, I figured I&amp;rsquo;d just jot down some notes here instead (in other words: Caution, untested braindumps ahead!).
Review First, let&amp;rsquo;s review the basic idea.</description>
    </item>
    
    <item>
      <title>Naming Convention for Matrix Math</title>
      <link>https://www.sebastiansylvan.com/post/matrix_naming_convention/</link>
      <pubDate>Thu, 27 Jul 2017 22:01:52 -0700</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/matrix_naming_convention/</guid>
      <description>There&amp;rsquo;s a fairly common naming convention for matrix math which makes most of the matrix math used in games as simple as slotting together Legos. This is by far the biggest bang-for-buck coding convention I know of. Ever randomly inverted a matrix or swapped the order of a matrix multiply until things look right? Yeah no, you never have to do that again. This really should be taught in graphics programming 101 because it pretty much eliminates all matrix transform headaches.</description>
    </item>
    
    <item>
      <title>Efficient Weighted Sampling</title>
      <link>https://www.sebastiansylvan.com/post/importancesampling/</link>
      <pubDate>Sat, 28 Jan 2017 12:56:31 -0800</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/importancesampling/</guid>
      <description>&lt;p&gt;Here&amp;rsquo;s a really simple and cheap way to do importance sampling that I came across a few months ago (while learning about &lt;a href=&#34;https://en.wikipedia.org/wiki/Particle_filter&#34;&gt;particle filters&lt;/a&gt;, incicentally). It&amp;rsquo;s simple enough that I have no idea how I went so long without ever knowing about it! In case anyone else is in the same boat - let me walk you through it. &lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Robust estimation</title>
      <link>https://www.sebastiansylvan.com/post/robustestimation/</link>
      <pubDate>Wed, 10 Aug 2016 20:58:27 -0700</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/robustestimation/</guid>
      <description>Least squares optimization is a super useful technique, and indeed I&amp;rsquo;ve used it twice on this blog before.
However, it has a major down side - it&amp;rsquo;s very susceptible to pollution by outliers. In one of my previous posts using least squares optimization I used a technique called RANSAC to deal with outliers, today I want to talk about a different approach.
The issue with least squares First, let&amp;rsquo;s recap the issue with least squares by working through a simple example.</description>
    </item>
    
    <item>
      <title>Doing Garbage Collection Without Requiring Uniform Representation</title>
      <link>https://www.sebastiansylvan.com/post/GCWithoutUniformRepr/</link>
      <pubDate>Wed, 06 Jul 2016 21:32:59 -0700</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/GCWithoutUniformRepr/</guid>
      <description>After some discussion on reddit recently the issue of uniform representation came up, and how it&amp;rsquo;s seemingly necessary to do GC, and what problems it causes. While I&amp;rsquo;m 99% sure I didn&amp;rsquo;t invent any of this, I can&amp;rsquo;t seem to find it while searching so I&amp;rsquo;ll just write down a quite note about how to do GC without enfocing uniform representation of objects.
Uniform representation So what is uniform representation?</description>
    </item>
    
    <item>
      <title>Tracking spheres in images (aka Let&#39;s Build a Half-Assed Playstation Move tracker!)</title>
      <link>https://www.sebastiansylvan.com/post/trackingspheres/</link>
      <pubDate>Sun, 22 May 2016 14:19:38 -0700</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/trackingspheres/</guid>
      <description>For fun, I decided to write basically a Playstation Move tracker. The idea is that you have some kind of glowing sphere with a known radius, take a picture of it with a camera, and infer where it is in 3D space. I bought these glowy balls since I don&amp;rsquo;t actually own a Playstation Move controller.
I ended up having some issues with my camera (possibly caused by running an internal windows build!</description>
    </item>
    
    <item>
      <title>On using &#39;auto&#39; and &#39;var&#39;</title>
      <link>https://www.sebastiansylvan.com/post/usingauto/</link>
      <pubDate>Thu, 17 Mar 2016 16:59:25 -0700</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/usingauto/</guid>
      <description>Programmers love to argue about coding standards, and one of the most contentious points is whether or not it should be allowed to use the equivalen to the &amp;ldquo;auto&amp;rdquo; keyword in C++ (in C# it&amp;rsquo;s called &amp;ldquo;var&amp;rdquo;, other language shave similar things). This is a keyword that does simple type propagation and lets you name a value without explicitly giving its type.
I don&amp;rsquo;t actually care all that much about coding standards, but this one bugs me because it seems to me that the main argument against allowing &amp;ldquo;auto&amp;rdquo; is a very transparent post-hoc justifications for &amp;ldquo;It&amp;rsquo;s unfamiliar to me, therefore bad&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Using SSE intrinsics to optimize scalar code</title>
      <link>https://www.sebastiansylvan.com/post/scalarsseintrinsics/</link>
      <pubDate>Tue, 23 Feb 2016 10:35:45 -0800</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/scalarsseintrinsics/</guid>
      <description>Just a quick note on optimizing scalar code using approximate SSE instructions. Now, first off let me just say that it&amp;rsquo;s rarely useful to micro-optimize scalar code (e.g. implementing Vector3 addition using SSE is probably a net loss, or at least wasted effort). If you really want to go fast, what you need to do is find hotspots which operates on a lot of data in a loop and turning that whole thing into SSE code.</description>
    </item>
    
    <item>
      <title>Fixing Texture Seams With Linear Least-Squares</title>
      <link>https://www.sebastiansylvan.com/post/LeastSquaresTextureSeams/</link>
      <pubDate>Mon, 16 Nov 2015 21:59:36 -0800</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/LeastSquaresTextureSeams/</guid>
      <description>&lt;p&gt;This post is about how use least squares optimization to slightly adjust the texel values in a texture in order to minimize seams across edges in UV-space. &lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Moving off of WordPress!</title>
      <link>https://www.sebastiansylvan.com/post/Moving-Off-Wordpress/</link>
      <pubDate>Wed, 04 Nov 2015 18:53:01 -0800</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/Moving-Off-Wordpress/</guid>
      <description>Whenever I would write blog posts on WordPress a huge source of friction was just how shitty the editing experience was. You could write the post elsewhere and then try to upload it but I found I was frequently surprised by things not looking quite right once WordPress was through with it. The online post editing tool was also an exercise in extreme frustration. So I decided to simplify my life a bit.</description>
    </item>
    
    <item>
      <title>Brackets are awesome, don’t use them!</title>
      <link>https://www.sebastiansylvan.com/post/brackets-are-awesome-dont-use-them/</link>
      <pubDate>Thu, 21 May 2015 05:10:23 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/brackets-are-awesome-dont-use-them/</guid>
      <description>This is a syntax bike-shedding post, where I will try to explain why I think languages should stop using curly brackets for code blocks. I don&amp;rsquo;t expect anyone to come away completely blown away by this or anything, but I&amp;rsquo;m a language nerd and often end up discussing in-development languages with their designers. And since approximately 90% of all language discussion is about syntax, I&amp;rsquo;ll just write a reusable note on brackets here.</description>
    </item>
    
    <item>
      <title>Why (most) High Level Languages are Slow</title>
      <link>https://www.sebastiansylvan.com/post/why-most-high-level-languages-are-slow/</link>
      <pubDate>Mon, 13 Apr 2015 06:27:31 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/why-most-high-level-languages-are-slow/</guid>
      <description>In the last month or two I&amp;rsquo;ve had basically the same conversation half a dozen times, both online and in real life, so I figured I&amp;rsquo;d just write up a blog post that I can refer to in the future.
The reason most high level languages are slow is usually because of two reasons:
 They don&amp;rsquo;t play well with the cache. They have to do expensive garbage collections  But really, both of these boil down to a single reason: the language heavily encourages too many allocations.</description>
    </item>
    
    <item>
      <title>Variable Refresh Monitors and Animation</title>
      <link>https://www.sebastiansylvan.com/post/variablerefresh/</link>
      <pubDate>Sat, 24 Jan 2015 00:51:57 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/variablerefresh/</guid>
      <description>So variable refresh rates have a lot of hype surrounding them now, with representatives from GPU and monitor vendors are saying that it will just magically make existing games better with no effort required on the part of the developer. This is bullshit and you shouldn&amp;rsquo;t believe them. If you&amp;rsquo;re a developer you need to be careful to handle these new refresh rates and if you&amp;rsquo;re a customer you should consider just locking your monitor to 60Hz for games that don&amp;rsquo;t do the right thing.</description>
    </item>
    
    <item>
      <title>Flags are a code smell</title>
      <link>https://www.sebastiansylvan.com/post/2014-04-27-flags-are-a-code-smell/</link>
      <pubDate>Sun, 27 Apr 2014 05:22:09 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/2014-04-27-flags-are-a-code-smell/</guid>
      <description>In most major code bases, it&amp;rsquo;s common to have objects with lots of Boolean flags indicating what state they&amp;rsquo;re in. E.g. is an enemy targeting the player or not? Is it trying to flee or not? If you have a set of mutually exclusive flags an enum can be used instead, but this is often not possible, and doesn&amp;rsquo;t change much in terms of the downsides.
In my opinion these are code smells.</description>
    </item>
    
    <item>
      <title>The Perils of Future-Coding</title>
      <link>https://www.sebastiansylvan.com/post/the-perils-of-future-coding/</link>
      <pubDate>Fri, 16 Aug 2013 07:47:38 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/the-perils-of-future-coding/</guid>
      <description>In my opinion, one of the most insidious form of technical debt is what I like to call future-coding. You might also call it over-engineering, second-system syndrome, etc. It&amp;rsquo;s code written in an overly elaborate and general way in order to, the future-coder reasons, pre-emptively handle use cases that we&amp;rsquo;ll &amp;ldquo;probably see in the future&amp;rdquo;.
I find it more treacherous than plain &amp;ldquo;stupid code&amp;rdquo; because it predominantly affects smart people.</description>
    </item>
    
    <item>
      <title>More on Robin Hood Hashing</title>
      <link>https://www.sebastiansylvan.com/post/more-on-robin-hood-hashing-2/</link>
      <pubDate>Mon, 05 Aug 2013 05:34:25 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/more-on-robin-hood-hashing-2/</guid>
      <description>I posted about Robin Hood hashing in a previous post. In the comments to that post David Wragg pointed out a flaw in my implementation: if you repeatedly delete and reinsert elements into a hashtable, the average probe count keeps rising. This is a good observation, and it&amp;rsquo;s true. Repeatedly deleting items makes the table slower but it (until you insert enough to trigger a rebuild of the table, which will filter out any tombstones - note: the number tombstones do not affect the rate of rebuilds).</description>
    </item>
    
    <item>
      <title>Language Design Deal Breakers</title>
      <link>https://www.sebastiansylvan.com/post/language-design-deal-breakers/</link>
      <pubDate>Sat, 25 May 2013 19:37:24 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/language-design-deal-breakers/</guid>
      <description>I&amp;rsquo;m a bit of a programming language nerd. I love to learn new languages. That said, I spend most of my days writing C++. It&amp;rsquo;s a truly awful language, with many warts and problems, but I know it well and with enough effort and pain you can get the job done. The biggest benefit of C++ is purely an historical accident: it&amp;rsquo;s great because it&amp;rsquo;s popular. There&amp;rsquo;s no trouble finding people who know it, or libraries that work with it.</description>
    </item>
    
    <item>
      <title>Robin Hood Hashing should be your default Hash Table implementation</title>
      <link>https://www.sebastiansylvan.com/post/robin-hood-hashing-should-be-your-default-hash-table-implementation/</link>
      <pubDate>Wed, 08 May 2013 02:44:43 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/robin-hood-hashing-should-be-your-default-hash-table-implementation/</guid>
      <description>There&amp;rsquo;s a neat variation on open-addressing based hash tables called Robin Hood hashing. This technique isn&amp;rsquo;t very well-known, but it makes a huge practical difference because it both improves performance and space utilization compared to other &amp;ldquo;standard&amp;rdquo; hash tables (e.g. chaining). It also eliminates the major downside of other open addressing hash tables.
Here are the benefits, summarized:
 High load factors can be used without seriously affecting performance. 0.</description>
    </item>
    
    <item>
      <title>Thoughts on Game Data Formats</title>
      <link>https://www.sebastiansylvan.com/post/thoughts-on-game-data-formats/</link>
      <pubDate>Sat, 04 May 2013 01:19:07 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/thoughts-on-game-data-formats/</guid>
      <description>I&amp;rsquo;ve been thinking about the representation and loading of game data recently. This has largely been the result of stumbling upon a variety of blog posts and libraries such as:
http://gamedevcoder.wordpress.com/2013/02/16/c-plus-plus-rtti-for-games/
http://kentonv.github.io/capnproto/install.html
http://blinkprotocol.org/
http://www.altdevblogaday.com/2012/06/04/read-my-lips-no-more-loading-screens/
 Desired characteristics So, the basic problem is that you want to store a large variety of &amp;ldquo;resources&amp;rdquo; for a game &amp;ldquo;level&amp;rdquo; (or &amp;ldquo;sector&amp;rdquo; or whatever), describing all sorts of things such as the location of every object, the vertices of every mesh, and so on.</description>
    </item>
    
    <item>
      <title>On GC in Games (response to Jeff and Casey)</title>
      <link>https://www.sebastiansylvan.com/post/on-gc-in-games-response-to-jeff-and-casey/</link>
      <pubDate>Thu, 18 Apr 2013 21:36:27 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/on-gc-in-games-response-to-jeff-and-casey/</guid>
      <description>So it turns out youtube comments suck. I&amp;rsquo;ll write my response to Jeff and Casey&amp;rsquo;s latest podcast in blog form instead of continuing the discussion there. View it here: http://www.youtube.com/watch?v=tK50z_gUpZI
Now, first let me say that I agree with 99% of the sentiment of this podcast. I think writing high performance games in Java or C# is kinda crazy, and the current trend of writing apps in HTML5 and JavaScript and then running it on top of some browser-like environment is positively bonkers.</description>
    </item>
    
    <item>
      <title>Runtime Code Specialization</title>
      <link>https://www.sebastiansylvan.com/post/runtime-code-specialization/</link>
      <pubDate>Fri, 22 Feb 2013 05:38:54 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/runtime-code-specialization/</guid>
      <description>Specializing code is nothing new, but I&amp;rsquo;m surprised that modern programming languages don&amp;rsquo;t attempt to make this easier.
Just to give you some context, the idea is that whenever you have an algorithm that takes multiple parameters where one or more of the parameters are fixed for some period of time, you specialize the code for the fixed parameters in order to achieve greater optimization at runtime. A key idea is that you may not know at compile time what the fixed value is, and the duration for which a value is fixed could be shorter than the execution of the program (mere milliseconds, even).</description>
    </item>
    
    <item>
      <title>Space-efficient Resizable Arrays</title>
      <link>https://www.sebastiansylvan.com/post/space-efficient-rresizable-arrays/</link>
      <pubDate>Wed, 19 Dec 2012 00:57:25 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/space-efficient-rresizable-arrays/</guid>
      <description>This post is about resizable arrays that would serve as an alternative to std::vector. You&amp;rsquo;re probably familiar with geometrically growing arrays like std::vector, so I won&amp;rsquo;t waste time describing them in detail. Briefly, they offer amortized constant-time append and lookups, but with a pretty severe cost to space overhead (as low as 33% utilization, after shrinking until you hit a realloc, or 50% if all you ever do is append). Another issue is that the elements of the array get copied ever so often.</description>
    </item>
    
    <item>
      <title>Garbage collection thoughts</title>
      <link>https://www.sebastiansylvan.com/post/garbage-collection-thoughts/</link>
      <pubDate>Sat, 01 Dec 2012 19:57:49 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/garbage-collection-thoughts/</guid>
      <description>One of the things that&amp;rsquo;s annoyed me for a while is that there aren&amp;rsquo;t any high performance, high level languages, really being seriously developed. It seems to me that most of the benefits from high level languages, if carefully designed, have no or very limited performance implications, but yet we get languages that either largely abandon safety and productivity concerns even when there&amp;rsquo;s no reason (iterations on C/C++ mostly, including Go and D), or we get high level languages that throw out performance considerations left and right for minor convenience reasons (e.</description>
    </item>
    
    <item>
      <title>OnLive and cloud gaming</title>
      <link>https://www.sebastiansylvan.com/post/onlive-and-cloud-gaming/</link>
      <pubDate>Sun, 19 Aug 2012 18:47:38 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/onlive-and-cloud-gaming/</guid>
      <description>So OnLive is having some trouble, leading a lot of people to proclaim the death of cloud gaming. Not me. I&amp;rsquo;m pretty convinced that cloud gaming is the inevitable future, the question is merely one of time.
First, let&amp;rsquo;s just talk about the technical issue of latency. It&amp;rsquo;s not solved right now, but it&amp;rsquo;s really not a fundamental law of physics like some people make out. Plenty of games released today have more than 100ms of latency, most of which is avoidable through software, and some of which can be avoided with better hardware and protocols (e.</description>
    </item>
    
    <item>
      <title>Casting a Critical Eye on GPU PTex</title>
      <link>https://www.sebastiansylvan.com/post/casting-a-critical-eye-on-gpu-ptex/</link>
      <pubDate>Sat, 23 Jun 2012 02:56:44 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/casting-a-critical-eye-on-gpu-ptex/</guid>
      <description>Storing data on the surfaces of meshes is somewhat of a pain. It involves unwrapping the surface into a 2D UV layout, which is time consuming and can lead to tricky issues such as seams and packing inefficiencies. I’m sure you know all about it.
For this reason, it makes sense to want to switch to some kind of automatic parameterization. Recently PTex has been proposed as a suitable approach for real-time graphics.</description>
    </item>
    
    <item>
      <title>Idea for efficient AO type raytracing applications</title>
      <link>https://www.sebastiansylvan.com/post/idea-for-efficient-ao-type-raytracing-applications/</link>
      <pubDate>Fri, 12 Aug 2011 04:40:21 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/idea-for-efficient-ao-type-raytracing-applications/</guid>
      <description>Quick idea that I had a few weeks ago regarding raytracing things like AO and potentially GI/FG. The basic observation is that for AO ray tracing you have far more rays than you have triangles, so it really doesn&amp;rsquo;t make sense that we only focus on spatial paritioning for the triangles. I suspect there&amp;rsquo;s some bias here because we&amp;rsquo;re so used to thinking of our rays as travelling around a static scene, so we just kind spatially subdivide the scene without even thinking about it.</description>
    </item>
    
    <item>
      <title>Implementation Inheritance Considered Harmful?</title>
      <link>https://www.sebastiansylvan.com/post/implementation-inheritance-considered-harmful/</link>
      <pubDate>Fri, 03 Dec 2010 18:59:51 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/implementation-inheritance-considered-harmful/</guid>
      <description>As the years go by and I see more and more painful bugs and convoluted architectures in OOP systems the more convinced I am that implementation inheritance is almost always the wrong answer, and that some kind of trait/mixin/delegation system is superior.
Inheritance sucks partly because you&amp;rsquo;re expected to extend a class that you didn&amp;rsquo;t write (or that you at least ostensibly plan to modify independently), by patching into a few of the methods here and there and mucking around with the &amp;ldquo;protected&amp;rdquo; innards.</description>
    </item>
    
    <item>
      <title>The &#34;inevitability&#34; of video game piracy</title>
      <link>https://www.sebastiansylvan.com/post/the-inevitability-of-video-game-piracy/</link>
      <pubDate>Sat, 16 Oct 2010 11:43:56 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/the-inevitability-of-video-game-piracy/</guid>
      <description>I just read yet another person say something along the lines of &amp;ldquo;there will always be piracy, it&amp;rsquo;s inevitable&amp;rdquo;. This line of thought bugs me. No, it&amp;rsquo;s not inevitable. It&amp;rsquo;s the best we can do right now for a variety of mostly non-technical reasons but it&amp;rsquo;s not that hard to come up with some rough proof-sketches that piracy can be 100% avoided, technically.
At the extreme you could have built in signature verification on the CPU itself so it will simply refuse to load any code that isn&amp;rsquo;t cryptographically signed for _that _chip and that chip alone, then distribute executables as DLC, with per-customer signatures.</description>
    </item>
    
    <item>
      <title>Idea for globally unique texturing without UV sets</title>
      <link>https://www.sebastiansylvan.com/post/idea-for-globally-unique-texturing-without-uv-sets/</link>
      <pubDate>Wed, 25 Aug 2010 19:48:31 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/idea-for-globally-unique-texturing-without-uv-sets/</guid>
      <description>Quick idea I’ve had for a while, but likely won’t have time to try out, for getting rid of UV sets once and for all by just looking up textures with a 3D position.
Start with a coarse grained 3D hash grid (i.e a hash map of your grid cell coordinates), then each of these cells would represent, say, a 2563 volume texture indexed by your vertex position. For compression (this volume data would be extremely sparse, usually little more than a flat 2D slice through it), it would use 3D Random Access trees (read this if you haven’t heard about primal vs dual subdivision – eye opener for me!</description>
    </item>
    
    <item>
      <title>How to teach Game Programming</title>
      <link>https://www.sebastiansylvan.com/post/how-to-teach-game-programming/</link>
      <pubDate>Sun, 22 Aug 2010 08:30:51 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/how-to-teach-game-programming/</guid>
      <description>I’m generally unimpressed by specialized game courses at university. Generally I’d be more inclined to trust a traditional CS or CE degree with a strong side-interest in game programming over a specialized game course.
One of the problems is that many game courses either don’t teach any low-level programming at all, or teach it poorly.
Obviously we still all use C++, so it’s crucial that you understand low-level programming, and every so often you actually need to know it for real, and not just because the language is too low level for you (e.</description>
    </item>
    
    <item>
      <title>R-trees – adapting out-of-core techniques to modern memory architectures</title>
      <link>https://www.sebastiansylvan.com/post/r-trees--adapting-out-of-core-techniques-to-modern-memory-architectures/</link>
      <pubDate>Sun, 11 Jul 2010 13:18:00 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/r-trees--adapting-out-of-core-techniques-to-modern-memory-architectures/</guid>
      <description>It’s been a couple of months since GDC, and I’ve been meaning to do a blog post about the talk I gave there (and if you have membership to the GDC vault you can even see a video).
An R-tree is a data structure for spatial indexing that’s optimized for out-of-core scenarios (basically databases). Spatial indexing is used for storing “stuff” in space. For example, a game might store all of the game objects in a spatial index so that we can efficiently query for things like “give me all objects that are within the view frustum”, or “give me all pairs of monsters and exploding barrels within 5m of each other”.</description>
    </item>
    
    <item>
      <title>Improving shadow map utilization for cascaded shadow maps</title>
      <link>https://www.sebastiansylvan.com/post/improving-shadow-map-utilization-for-cascaded-shadow-maps/</link>
      <pubDate>Sat, 24 Apr 2010 19:26:44 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/improving-shadow-map-utilization-for-cascaded-shadow-maps/</guid>
      <description>Jonathan Blow is working on stable cascaded shadow maps, and trying to reduce wasted texels due to the way the shadow frustum is set up. Well, as it happens I have my own minor tweak to Valient’s technique that also reduces wastage, so I&amp;rsquo; figured I’d describe it here with pretty pictures. I’m going to assume that you’re roughly familiar with the general idea, if not, read e.g. Blow’s first blog post on the topic, or ShaderX 6.</description>
    </item>
    
    <item>
      <title>The problem with tessellation in DirectX 11</title>
      <link>https://www.sebastiansylvan.com/post/the-problem-with-tessellation-in-directx-11/</link>
      <pubDate>Sun, 18 Apr 2010 18:32:44 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/the-problem-with-tessellation-in-directx-11/</guid>
      <description>As you may have heard, Direct X 11 brings tessellation support, and all the hardware vendors and benchmarks are going crazy with super-finely tessellated meshes, promising us automatic level of detail and unprecedented visual fidelity. What you may not be aware of is that the Xbox 360 has very similar tessellation hardware too, which means many game developers have had the opportunity to use these same techniques for about five years now.</description>
    </item>
    
    <item>
      <title>Two Performance Walls Approaching</title>
      <link>https://www.sebastiansylvan.com/post/two-performance-walls-approaching/</link>
      <pubDate>Sun, 22 Nov 2009 03:02:32 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/two-performance-walls-approaching/</guid>
      <description>I just watched a panel from PDC called Microsoft Perspectives on the Future of Programming with loads of “big name” programming gurus. At the end of the session Herb Sutter points out that eventually Moore’s law will end, and then optimization will become extremely sexy again. This is a very good point, but I think there’s another law that will cause optimization to become sexy again far sooner than that: Almdahl’s law.</description>
    </item>
    
    <item>
      <title>Ray tracing signed distance functions</title>
      <link>https://www.sebastiansylvan.com/post/ray-tracing-signed-distance-functions/</link>
      <pubDate>Sat, 04 Jul 2009 23:09:19 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/ray-tracing-signed-distance-functions/</guid>
      <description>Signed Distance Functions are a pretty simple concept. Basically for each point in the world, you return a distance to the nearest surface, negative distances are inside geometry. One neat application of them to represent scene geometry, and ray trace into the SDF. Why would anyone do such a thing? Well, it turns out that when marching along a ray looking for intersections (which is obviously not the only way to trace rays), it’s jolly useful to know a minimum bound on when you might expect to encounter a surface.</description>
    </item>
    
    <item>
      <title>Why sales of used games are a problem</title>
      <link>https://www.sebastiansylvan.com/post/why-sales-of-used-games-are-a-problem/</link>
      <pubDate>Wed, 01 Jul 2009 21:20:43 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/why-sales-of-used-games-are-a-problem/</guid>
      <description>A few days ago industry analyst Michael Pachter said the following:
 The number of games traded annually is striking; we estimate the overall used game market to be $2 billion in the U.S., with an average ticket of around $20 per used game. This means that an estimated 100 million units of used games are traded in each year, representing around 1/3 of all games sold annually.
 Blimey! That’s a lot of money, and what’s worse it’s money that goes directly into the pockets of retailers, you know the people who do not fund the development of games, and do not take any risks.</description>
    </item>
    
    <item>
      <title>The prosecutor&#39;s fallacy and the Iranian elections</title>
      <link>https://www.sebastiansylvan.com/post/2009-06-27-the-prosecutors-fallacy-and-the-iranian-elections/</link>
      <pubDate>Sat, 27 Jun 2009 18:22:00 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/2009-06-27-the-prosecutors-fallacy-and-the-iranian-elections/</guid>
      <description>A few years ago I watched TED talk by Peter Donnelly dealing with statistics, and in particular the prosecutor’s fallacy. You can view it here. This was a thoroughly enjoyable talk and I recommend everyone to watch it. However, it turns out that not even statisticians are immune to making this basic error, as this recent article by Bernd Beber and Alexandra Scacco about the probabilities of election fraud in Iran shows.</description>
    </item>
    
    <item>
      <title>The prosecutor’s fallacy and the Iranian elections</title>
      <link>https://www.sebastiansylvan.com/post/the-prosecutor%e2%80%99s-fallacy-and-the-iranian-elections/</link>
      <pubDate>Sat, 27 Jun 2009 18:22:00 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/post/the-prosecutor%e2%80%99s-fallacy-and-the-iranian-elections/</guid>
      <description>A few years ago I watched TED talk by Peter Donnelly dealing with statistics, and in particular the prosecutor’s fallacy. You can view it here. This was a thoroughly enjoyable talk and I recommend everyone to watch it. However, it turns out that not even statisticians are immune to making this basic error, as this recent article by Bernd Beber and Alexandra Scacco about the probabilities of election fraud in Iran shows.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://www.sebastiansylvan.com/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.sebastiansylvan.com/about/</guid>
      <description>My name is Sebastian Sylvan. I&amp;rsquo;m from Sweden but live in Seattle. I work at Waymo, previously Google and Microsoft (VR/AR, games). Obviously my views are my own and don&amp;rsquo;t necessarily represent those of my employer.
I typically blog graphics, languages, performance, and such. Feel free to hit me up on twitter or email (see links in sidebar).</description>
    </item>
    
  </channel>
</rss>